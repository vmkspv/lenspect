# report_composer.py
#
# Copyright 2025 Vladimir Kosolapov
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later

from gi.repository import Gio, GLib
from ..vt_provider import FileAnalysis, URLAnalysis

class ReportComposer:
    def generate_report(self, analysis, filename=None):
        if not analysis:
            return ""

        sections = []

        header = f"{_('Generated by Lenspect - VirusTotal Scanner for Linux')}"
        sections.append([header])

        if isinstance(analysis, FileAnalysis):
            filename = analysis.file_name or filename
            file_size = analysis.formatted_size if analysis.file_size > 0 else _('Unknown size')
            file_type = analysis.file_type or _('Unknown type')

            info_section = [
                f"=== {_('File Information')} ===",
                f"{_('Filename')}: {filename}",
                f"{_('Size')}: {file_size}",
                f"{_('Type')}: {file_type}",
                f"{_('First Submission')}: {analysis.first_submission_date}",
                f"{_('Last Analysis')}: {analysis.last_analysis_date}",
                f"{_('Times Submitted')}: {analysis.times_submitted}"
            ]
            sections.append(info_section)

        elif isinstance(analysis, URLAnalysis):
            url_title = analysis.title or _('Untitled')
            info_section = [
                f"=== {_('URL Information')} ===",
                f"{_('URL')}: {analysis.url}",
                f"{_('Title')}: {url_title}",
                f"{_('Final URL')}: {analysis.final_url}",
                f"{_('First Submission')}: {analysis.first_submission_date}",
                f"{_('Last Analysis')}: {analysis.last_analysis_date}",
                f"{_('Times Submitted')}: {analysis.times_submitted}",
                f"{_('Community Score')}: {analysis.community_score}"
            ]
            sections.append(info_section)

            redirect_chain = analysis.get_redirect_chain()
            if redirect_chain:
                redirect_section = [f"=== {_('Redirection Chain')} ==="]
                for i, url in enumerate(redirect_chain):
                    redirect_section.append(f"{_('Redirect')} {i+1}: {url}")
                sections.append(redirect_section)

            categories = analysis.get_categories()
            if categories:
                categories_section = [f"=== {_('Categories')} ==="]
                for vendor, category in sorted(categories.items(), key=lambda x: x[0].lower()):
                    categories_section.append(f"{vendor}: {category}")
                sections.append(categories_section)

        stats_section = [
            f"=== {_('Detection Statistics')} ===",
            f"{_('Malicious')}: {analysis.malicious_count}",
            f"{_('Suspicious')}: {analysis.suspicious_count}",
            f"{_('Clean')}: {analysis.harmless_count}",
            f"{_('Undetected')}: {analysis.undetected_count}",
            f"{_('Total Vendors')}: {analysis.total_vendors}"
        ]
        sections.append(stats_section)

        if analysis.threat_count > 0:
            detections = analysis.get_detections()
            if detections:
                threats_section = [f"=== {_('Threat Detections')} ==="]
                for vendor, detection in sorted(detections.items(), key=lambda x: x[0].lower()):
                    threats_section.append(f"{vendor}: {detection}")
                sections.append(threats_section)

        return "\n\n".join("\n".join(section) for section in sections)

    def generate_filename(self):
        timestamp = GLib.DateTime.new_now_local().format("%Y%m%d_%H%M%S")
        return f"lenspect_{timestamp}.txt"

    def save_to_file(self, report_text: str, file_path: str):
        try:
            gfile = Gio.File.new_for_path(file_path)
            gfile.replace_contents(
                report_text.encode("utf-8"), None, False,
                Gio.FileCreateFlags.NONE, None)
            return True
        except GLib.Error:
            return False
